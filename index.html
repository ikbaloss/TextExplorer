<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Word Tree - Searchable Concordance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root { --primary: #2563eb; --bg: #f3f4f6; --border: #d1d5db; --root-bg: #fef3c7; --root-stroke: #d97706; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; margin: 0; background: var(--bg); display: flex; flex-direction: column; min-height: 100vh; }
        .sidebar { background: #ffffff; padding: 10px 20px; border-bottom: 1px solid var(--border); display: flex; flex-wrap: wrap; gap: 12px; position: sticky; top: 0; z-index: 1000; box-shadow: 0 2px 4px rgba(0,0,0,0.1); align-items: flex-end; }
        .control-group { display: flex; flex-direction: column; }
        label { font-size: 9px; font-weight: 800; color: #6b7280; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        input, select { padding: 6px; border: 1px solid var(--border); border-radius: 4px; font-size: 12px; background: white; }
        .actions { display: flex; gap: 12px; margin-left: auto; align-items: flex-end; }
        button { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px; transition: 0.2s; height: 32px; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-success { background: #10b981; color: white; }
        .btn-csv { background: #8b5cf6; color: white; }
        #viewport { width: 100%; background: #cbd5e1; display: flex; align-items: center; justify-content: center; overflow: auto; padding: 20px 0; border-bottom: 2px solid var(--border); }
        #chart-container { background: white; border: 1px solid #94a3b8; box-shadow: 0 4px 15px rgba(0,0,0,0.1); overflow: hidden; }
        .concordance-wrapper { background: white; padding: 30px; }
        .table-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px; }
        .search-box { position: relative; width: 300px; }
        .search-box input { width: 100%; padding: 8px 12px; font-size: 13px; border: 2px solid var(--primary); outline: none; }
        .table-container { background: white; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; table-layout: auto; }
        th { background: #f9fafb; padding: 12px; border-bottom: 2px solid var(--border); color: #4b5563; font-size: 10px; text-transform: uppercase; }
        .group-header { background: #f1f5f9; color: #1e293b; font-weight: 800; font-size: 11px; padding: 8px 15px; text-transform: uppercase; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); }
        .col-file { width: 120px; color: #6366f1; font-weight: 600; font-size: 11px; border-right: 1px solid var(--border); padding-left: 10px; }
        .col-left { text-align: right; vertical-align: middle; width: 35%; }
        .col-focus { width: 1%; white-space: nowrap; text-align: center; background: #fff1f1; border-left: 1px solid #fee2e2; border-right: 1px solid #fee2e2; vertical-align: middle; padding: 10px 15px; }
        .col-right { text-align: left; vertical-align: middle; width: 35%; }
        .cell-wrap-left { margin-right: 15px; color: #4b5563; line-height: 1.4; }
        .cell-wrap-right { margin-left: 15px; color: #6b7280; line-height: 1.4; }
        .focus-text { font-weight: 700; color: #dc2626; display: inline-block; }
        .link { fill: none; stroke: #94a3b8; stroke-width: 1.5px; opacity: 0.6; }
        .node circle { fill: #fff; stroke: #2563eb; stroke-width: 1.5px; cursor: pointer; }
        .node text { font-family: sans-serif; fill: #1f2937; pointer-events: none; }
        .root-node rect { fill: var(--root-bg); stroke: var(--root-stroke); stroke-width: 2.5px; cursor: pointer; }
        .root-node text { font-weight: 900; fill: #92400e; pointer-events: none; }
        .toggle-group { display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: 600; color: #4b5563; }
        .disabled-toggle { opacity: 0.4; cursor: not-allowed; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <div class="control-group"><label>1. Text Files</label><input type="file" id="fileInput" accept=".txt" multiple></div>
    <div class="control-group"><label>1b. Stopwords</label><input type="file" id="stopwordInput" accept=".txt"></div>
    <div class="control-group"><label>2. Top Words</label><select id="tfidfSelect" style="width: 160px;"><option value="">Upload files...</option></select></div>
    <div class="control-group"><label>3. Keyword</label><input type="text" id="keyword" placeholder="Manual..."></div>
    <div class="control-group" style="width: 35px;"><label>Br.</label><input type="number" id="maxBranches" value="3"></div>
    <div class="control-group" style="width: 35px;"><label>Span</label><input type="number" id="windowSpan" value="5"></div>
    <div class="control-group" style="width: 60px;"><label>Box W</label><input type="number" id="boxWidth" onchange="resizeBox()"></div>
    <div class="control-group" style="width: 60px;"><label>Box H</label><input type="number" id="boxHeight" onchange="resizeBox()"></div>
    <div class="control-group"><label>Tree Filter</label><label class="toggle-group disabled-toggle" id="swLabel"><input type="checkbox" id="hideStopwordsToggle" onchange="processText()" disabled> Hide Stopwords</label></div>
    <div class="actions">
        <div class="control-group" style="width: 100px;"><label>Font Size</label><input type="range" id="fontSizeSlider" min="6" max="32" value="11" oninput="updateFontSize(this.value)"></div>
        <button class="btn-primary" onclick="processText()">Generate</button>
        <button class="btn-success" onclick="saveAsPNG()">PNG</button>
    </div>
</div>

<div id="viewport"><div id="chart-container"><svg id="wordTree"></svg></div></div>

<div class="concordance-wrapper">
    <div class="table-controls">
        <div>
            <div id="tableTitle" style="font-size:18px; font-weight:700;">Concordance Table</div>
            <div id="matchCount" style="color: #6b7280; font-size: 13px; margin-top: 4px;">0 matches</div>
        </div>
        
        <div class="search-box">
            <label>Search in Table</label>
            <input type="text" id="tableSearch" placeholder="Filter contexts..." oninput="refreshTable()">
        </div>

        <div style="display: flex; gap: 20px; align-items: center;">
            <label class="toggle-group"><input type="checkbox" id="groupByFileToggle" onchange="refreshTable()"> Group by File</label>
            <button class="btn-csv" onclick="saveToCSV()">CSV Export</button>
        </div>
    </div>
    
    <div class="table-container">
        <table id="concordanceTable">
            <thead><tr><th style="width:120px; text-align: left; padding-left:10px;">File</th><th class="col-left">Left Context</th><th class="col-focus">Focus (N-Gram)</th><th class="col-right">Right Context</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<script>
let corpus = [];
let customStopWords = new Set();
let globalOccurrences = [];
let lastMatches = [];
const zoomHandler = d3.zoom().on("zoom", (e) => d3.select("#main-g").attr("transform", e.transform));

window.addEventListener('load', () => {
    document.getElementById('boxWidth').value = Math.floor(window.innerWidth - 40);
    document.getElementById('boxHeight').value = 700;
    resizeBox();
});

function resizeBox() {
    const w = document.getElementById('boxWidth').value, h = document.getElementById('boxHeight').value;
    const container = document.getElementById('chart-container');
    container.style.width = w + "px"; container.style.height = h + "px";
    d3.select("#wordTree").attr("width", w).attr("height", h);
}

document.getElementById('fileInput').addEventListener('change', async e => {
    corpus = [];
    for (let file of Array.from(e.target.files)) corpus.push({ name: file.name, content: await file.text() });
    runRobustTFIDF();
});

document.getElementById('stopwordInput').addEventListener('change', e => {
    const reader = new FileReader();
    reader.onload = ev => { 
        customStopWords = new Set(ev.target.result.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w));
        document.getElementById('hideStopwordsToggle').disabled = false;
        document.getElementById('swLabel').classList.remove('disabled-toggle');
        if (corpus.length) runRobustTFIDF();
    };
    reader.readAsText(e.target.files[0]);
});

document.getElementById('tfidfSelect').onchange = function() { if(this.value) { document.getElementById('keyword').value = this.value; processText(); } };

function runRobustTFIDF() {
    let docFrequency = {}, relativeTFSum = {}, rawFrequency = {}, totalSentences = 0;
    corpus.forEach(doc => {
        const sentences = doc.content.split(/[.!?\n]+/).map(s => s.trim().toLowerCase()).filter(s => s.length > 5);
        totalSentences += sentences.length;
        sentences.forEach(s => {
            const tokens = s.replace(/[^\w\s]/g, "").split(/\s+/).filter(t => t.length > 2);
            const counts = {};
            tokens.forEach(t => { counts[t] = (counts[t] || 0) + 1; rawFrequency[t] = (rawFrequency[t] || 0) + 1; });
            Object.keys(counts).forEach(word => {
                relativeTFSum[word] = (relativeTFSum[word] || 0) + (counts[word] / tokens.length);
                docFrequency[word] = (docFrequency[word] || 0) + 1;
            });
        });
    });
    const top50 = Object.keys(relativeTFSum).filter(word => !customStopWords.has(word))
        .map(word => ({ word, score: relativeTFSum[word] * Math.log(totalSentences / docFrequency[word]), freq: rawFrequency[word] }))
        .sort((a,b) => b.score - a.score).slice(0, 50);
    const select = document.getElementById('tfidfSelect');
    select.innerHTML = '<option value="">Select a Smart Keyword...</option>';
    top50.forEach(item => { const opt = document.createElement('option'); opt.value = item.word; opt.innerText = `${item.word.toUpperCase()} (${item.freq})`; select.appendChild(opt); });
}

function processText() {
    const keyword = document.getElementById('keyword').value.trim().toLowerCase();
    if (!keyword || !corpus.length) return;
    resizeBox();
    globalOccurrences = [];
    const leftS = [], rightS = [], span = parseInt(document.getElementById('windowSpan').value);
    const hideSW = document.getElementById('hideStopwordsToggle').checked;

    corpus.forEach(doc => {
        doc.content.split(/[.!?\n]+/).forEach(s => {
            const tokens = s.trim().split(/\s+/).filter(t => t.length > 0);
            const normTokens = tokens.map(t => t.replace(/[^\w-]/g, "").toLowerCase());
            normTokens.forEach((norm, idx) => {
                if (norm === keyword) {
                    globalOccurrences.push({ fileName: doc.name, tokens, normTokens, kIdx: idx });
                    let lSeq = normTokens.slice(Math.max(0, idx - 15), idx).reverse();
                    let rSeq = normTokens.slice(idx + 1, idx + 16);
                    if (hideSW) { lSeq = lSeq.filter(w => !customStopWords.has(w)); rSeq = rSeq.filter(w => !customStopWords.has(w)); }
                    leftS.push(lSeq.slice(0, span));
                    rightS.push(rSeq.slice(0, span));
                }
            });
        });
    });
    if (globalOccurrences.length === 0) return alert("Keyword not found.");
    drawTree(buildTrie(leftS, globalOccurrences.length), buildTrie(rightS, globalOccurrences.length), keyword);
    lastMatches = globalOccurrences.map(o => ({...o, start: o.kIdx, end: o.kIdx}));
    document.getElementById('tableSearch').value = ""; // Reset search on new keyword
    updateTable(lastMatches);
}

function buildTrie(sequences, count) {
    const root = { name: "", children: [], count: count }, maxB = parseInt(document.getElementById('maxBranches').value);
    sequences.forEach(seq => {
        let current = root;
        seq.forEach(word => {
            let child = current.children.find(d => d.name === word);
            if (!child) { child = { name: word, children: [], count: 1 }; current.children.push(child); } else { child.count++; }
            current = child;
        });
    });
    const prune = (n) => { if (n.children) { n.children.sort((a,b) => b.count - a.count).splice(maxB); n.children.forEach(prune); } };
    prune(root); return root;
}

function refreshTable() { updateTable(lastMatches); }

function updateTable(matches) {
    lastMatches = matches;
    const tbody = document.querySelector("#concordanceTable tbody");
    const searchQuery = document.getElementById('tableSearch').value.toLowerCase();
    tbody.innerHTML = "";
    
    // Filter matches by search query if present
    let displayData = [...matches];
    if (searchQuery) {
        displayData = displayData.filter(m => {
            const left = m.tokens.slice(Math.max(0, m.start-15), m.start).join(" ").toLowerCase();
            const focus = m.tokens.slice(m.start, m.end + 1).join(" ").toLowerCase();
            const right = m.tokens.slice(m.end + 1, m.end + 16).join(" ").toLowerCase();
            return left.includes(searchQuery) || focus.includes(searchQuery) || right.includes(searchQuery);
        });
    }

    document.getElementById('matchCount').innerText = `${displayData.length} matches shown`;
    if (document.getElementById('groupByFileToggle').checked) displayData.sort((a, b) => a.fileName.localeCompare(b.fileName));
    
    let lastFile = null;
    displayData.forEach(m => {
        if (document.getElementById('groupByFileToggle').checked && m.fileName !== lastFile) {
            const groupRow = document.createElement("tr");
            groupRow.innerHTML = `<td colspan="4" class="group-header">ðŸ“„ Document: ${m.fileName}</td>`;
            tbody.appendChild(groupRow);
            lastFile = m.fileName;
        }
        const tr = document.createElement("tr");
        tr.innerHTML = `<td class="col-file">${m.fileName}</td>
            <td class="col-left"><div class="cell-wrap-left">${m.tokens.slice(Math.max(0, m.start-15), m.start).join(" ")}</div></td>
            <td class="col-focus"><span class="focus-text">${m.tokens.slice(m.start, m.end + 1).join(" ")}</span></td>
            <td class="col-right"><div class="cell-wrap-right">${m.tokens.slice(m.end + 1, m.end + 16).join(" ")}</div></td>`;
        tbody.appendChild(tr);
    });
}

function filterTableByPath(d, side) {
    const sequence = d.ancestors().reverse().map(n => n.data.name).filter(n => n !== "");
    const hideSW = document.getElementById('hideStopwordsToggle').checked;
    
    const filtered = globalOccurrences.map(occ => {
        let match = true, start = occ.kIdx, end = occ.kIdx;
        if (side === 'right') {
            let foundCount = 0, currentIdx = occ.kIdx + 1;
            while (foundCount < sequence.length && currentIdx < occ.normTokens.length) {
                let word = occ.normTokens[currentIdx];
                if (hideSW && customStopWords.has(word)) { currentIdx++; continue; }
                if (word === sequence[foundCount]) { end = currentIdx; foundCount++; currentIdx++; } else { match = false; break; }
            }
            if (foundCount < sequence.length) match = false;
        } else {
            let foundCount = 0, currentIdx = occ.kIdx - 1;
            while (foundCount < sequence.length && currentIdx >= 0) {
                let word = occ.normTokens[currentIdx];
                if (hideSW && customStopWords.has(word)) { currentIdx--; continue; }
                if (word === sequence[foundCount]) { start = currentIdx; foundCount++; currentIdx--; } else { match = false; break; }
            }
            if (foundCount < sequence.length) match = false;
        }
        return match ? { ...occ, start, end } : null;
    }).filter(x => x !== null);
    updateTable(filtered);
}

function drawTree(lData, rData, keyword) {
    const svg = d3.select("#wordTree");
    svg.selectAll("*").remove();
    const g = svg.append("g").attr("id", "main-g");
    svg.call(zoomHandler);
    const treeLayout = d3.tree().nodeSize([45, 200]);
    const lRoot = d3.hierarchy(lData), rRoot = d3.hierarchy(rData);
    treeLayout(lRoot); treeLayout(rRoot);
    const fSize = document.getElementById('fontSizeSlider').value;
    g.selectAll(".link").data(lRoot.links().concat(rRoot.links())).enter().append("path").attr("class", "link").attr("d", d => {
        const isLeft = lRoot.descendants().includes(d.source);
        return d3.linkHorizontal().x(x => isLeft ? -x.y : x.y).y(y => y.x)(d);
    });
    const renderNodes = (root, side) => {
        const nodes = g.selectAll(`.n-${side}`).data(root.descendants()).enter().append("g").attr("class", "node")
            .attr("transform", d => `translate(${side==='left' ? -d.y : d.y}, ${d.x})`)
            .on("click", (e, d) => { if(d.depth > 0) filterTableByPath(d, side); })
            .on("dblclick", (e, d) => { e.stopPropagation(); document.getElementById('keyword').value = d.data.name; processText(); });
        nodes.filter(d => d.depth > 0).append("circle").attr("r", 5);
        nodes.filter(d => d.depth > 0).append("text").attr("dy", "0.35em").attr("x", d => side === 'left' ? (d.children ? 12 : -12) : (d.children ? -12 : 12))
            .style("text-anchor", d => side === 'left' ? (d.children ? "start" : "end") : (d.children ? "end" : "start"))
            .style("font-size", fSize + "px").text(d => `${d.data.name} (${d.data.count})`);
    };
    renderNodes(lRoot, 'left'); renderNodes(rRoot, 'right');
    const rootN = g.append("g").attr("class", "root-node").on("click", () => updateTable(globalOccurrences.map(o => ({...o, start: o.kIdx, end: o.kIdx}))));
    const rt = rootN.append("text").attr("text-anchor", "middle").attr("dy", "6px").style("font-size", (parseInt(fSize)+2) + "px").text(`${keyword} (${lData.count})`);
    const b = rt.node().getBBox();
    rootN.insert("rect", "text").attr("x", b.x-15).attr("y", b.y-8).attr("width", b.width+30).attr("height", b.height+16).attr("rx", 6);
    autoFit();
}

function autoFit() {
    const svg = d3.select("#wordTree"), g = d3.select("#main-g"), b = g.node().getBBox(), w = parseInt(document.getElementById('boxWidth').value), h = parseInt(document.getElementById('boxHeight').value);
    const s = 0.8 / Math.max(b.width/w, b.height/h);
    svg.transition().duration(750).call(zoomHandler.transform, d3.zoomIdentity.translate(w/2 - s*(b.x+b.width/2), h/2 - s*(b.y+b.height/2)).scale(s));
}

function updateFontSize(val) {
    d3.selectAll(".node text").style("font-size", val + "px");
    const rt = d3.select(".root-node text");
    if(!rt.empty()){
        rt.style("font-size", (parseInt(val)+2)+"px");
        const b = rt.node().getBBox();
        d3.select(".root-node rect").attr("x", b.x-15).attr("y", b.y-8).attr("width", b.width+30).attr("height", b.height+16);
    }
}

function saveToCSV() {
    const rows = document.querySelectorAll("#concordanceTable tr:not(.group-header)");
    if (rows.length <= 1) return;
    let csv = "\uFEFFFile,Left Context,Focus,Right Context\n";
    for (let i = 1; i < rows.length; i++) csv += Array.from(rows[i].querySelectorAll("td")).map(c => `"${c.innerText.replace(/"/g, '""')}"`).join(",") + "\n";
    const link = document.createElement("a"); link.href = URL.createObjectURL(new Blob([csv], { type: 'text/csv;charset=utf-8;' })); link.download = `corpus_search.csv`; link.click();
}

function saveAsPNG() {
    const svg = document.getElementById('wordTree'), fSize = document.getElementById('fontSizeSlider').value;
    const serializer = new XMLSerializer();
    let source = serializer.serializeToString(svg);
    const styleBlock = `<style>.link { fill: none; stroke: #94a3b8 !important; stroke-width: 1.5px !important; opacity: 0.8; }.node circle { fill: #ffffff; stroke: #2563eb; stroke-width: 1.5px; }.node text { font-family: sans-serif; fill: #1f2937; font-size: ${fSize}px; }.root-node rect { fill: #fef3c7 !important; stroke: #d97706 !important; stroke-width: 2.5px; }.root-node text { font-weight: 900; fill: #92400e !important; font-family: sans-serif; font-size: ${parseInt(fSize)+2}px; }</style>`;
    source = source.replace('>', `>${styleBlock}`);
    const canvas = document.createElement("canvas"); canvas.width = svg.clientWidth * 2; canvas.height = svg.clientHeight * 2;
    const ctx = canvas.getContext("2d"); const img = new Image();
    img.onload = () => { ctx.fillStyle = "white"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); const a = document.createElement("a"); a.href = canvas.toDataURL("image/png"); a.download = `tree.png`; a.click(); };
    img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(source)));
}
</script>
</body>
</html>